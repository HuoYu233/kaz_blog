<!DOCTYPE html>
<html>
  <!-- meta/link... -->
  



<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>【文献阅读】ProteinMPNN | Kaz&#39;s Blog</title>

  <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link href="/js/swiper/swiper@5.4.1.min.css" rel="stylesheet">
  
  
  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    <link href="https://unpkg.com/@fancyapps/ui@5.0/dist/fancybox/fancybox.css" rel="stylesheet">
  
  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script defer src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

    
    
    <!-- 依赖于jquery和vue -->
    <script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>
    <script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"></script>

    <!-- import link -->
    
        
            
        
            
        
    
    <!-- import script -->
    
        
            
        
            
        
    

<meta name="generator" content="Hexo 7.3.0"></head>

  
  <!-- 预加载动画 -->
  
  
  <div class="preloader_6" id="loader">
  <div class="loader"></div>
</div>
  <script>
    var endLoading = function () {
      document.body.style.overflow = 'auto';
      document.getElementById('loader').classList.add("loaded");
    }
    window.addEventListener('DOMContentLoaded', endLoading);
  </script>


  <body>
    <!-- 判断是否为暗黑风格 -->
    <!-- 判断是否为黑夜模式 -->
<script defer>
  let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

  if (isDark) {
    $(document.body).addClass('darkModel');
  }
</script>

    <!-- 需要在上面加载的js -->
    <script>
  function loadScript(src, cb) {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }

  //https://github.com/filamentgroup/loadCSS
  var loadCSS = function (src) {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  };

</script> 

<!-- 轮播图所需要的js -->
<script src="/js/swiper/swiper.min.js"></script>
<script src="/js/swiper/vue-awesome-swiper.js"></script>
<script src="/js/swiper/swiper.animate1.0.3.min.js"></script>

<script type="text/javascript">
  Vue.use(window.VueAwesomeSwiper)
</script>


  <script src="/js/vue-typed-js/index.js"></script>


<!-- 首页的公告滚动插件的js需要重新加载 -->
<script src="/js/vue-seamless-scroll/index.js"></script>

<!-- 打字机效果js -->
<script src="https://unpkg.com/typed.js@2.0.11"></script>


    <div id="safearea">
      <main class="main" id="pjax-container">
        <!-- 头部导航 -->
        
<header class="header  " 
  id="navHeader"
  style="position: fixed;
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <div class="drawer-box-icon">
    <i class="fas fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  </div>
  
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo lazyload placeholder" src="/img/favicon.ico" class="lazyload placeholder" data-srcset="/img/favicon.ico" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
      <h3 class="drawer-box-head_title">Kaz&#39;s Blog</h3>
      <h5 class="drawer-box-head_desc"></h5>
    </div>
    
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/about" class="drawer-menu-item-link">
                  
                    <i class="fas fa-user" aria-hidden="true"></i>
                  
                  <span class="name">About</span>
                </a>
              
            </li>
          
            <li class="drawer-box-content_item" style="position: relative;">
              
                <a href="/log" class="drawer-menu-item-link">
                  
                    <i class="fas fa-book" aria-hidden="true"></i>
                  
                  <span class="name">Log</span>
                </a>
              
            </li>
          
        
        
          <li class="drawer-box-content_item">
            <a target="_blank" rel="noopener" href="https://github.com/HuoYu233">
              <i class="fas fa-github" aria-hidden="true"></i>
              <span>Github</span>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
      openArr: [],
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      isOpen(index) {
        if (this.openArr.includes(index)) {
          return true;
        } else {
          return false;
        }
      },
      openOrCloseMenu(curIndex) {
        const index = this.openArr.indexOf(curIndex);
        if (index !== -1) {
          this.openArr.splice(index, 1);
        } else {
          this.openArr.push(curIndex);
        }
      },
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%;overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>

    </div>
    <div class="blog-title" id="author-avatar">
      
        <div class="avatar">
          <img src="/img/favicon.ico" class="lazyload placeholder" data-srcset="/img/favicon.ico" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
        </div>
      
      <a href="/" class="logo">Kaz&#39;s Blog</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/about" class="menu-item-link" title="About">
                  
                    <i class="fas fa-user" aria-hidden="true"></i>
                  
                  <span class="name">About</span>
                </a>
              
            </li>
          
            <li class="menu-item" style="position: relative;">
              
                <a href="/log" class="menu-item-link" title="Log">
                  
                    <i class="fas fa-book" aria-hidden="true"></i>
                  
                  <span class="name">Log</span>
                </a>
              
            </li>
          
        
      </ul>
      
      

    </nav>
  </div>
  
    <a target="_blank" rel="noopener" href="https://github.com/HuoYu233" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
  
</header>
        <!-- 内容区域 -->
        
<!-- prismjs 代码高亮 -->




<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>


  <!-- 文章详情页顶部图片和标题 -->




<div class="post-detail-header" id="thumbnail_canvas" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;background-image:url('https://camo.githubusercontent.com/d1a1014ab71380dccf048c2f60a54de6954ccc670f321b0ed6bf4d8af1fb3699/68747470733a2f2f646f63732e676f6f676c652e636f6d2f64726177696e67732f642f652f32504143582d317654746e4d42444f71385470484963745566474e38566c3332783549534e63504b6c786a63514a4632713730506c61483275466c6a3241633473336b686e5a71473159787070644d72306954796b2d2f7075623f773d38383926683d333538')">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0;pointer-events:none;"></canvas>
  
  <div class="post-detail-header_info-box">
    <div class="title-box">
      <span class="title">
        【文献阅读】ProteinMPNN
      </span>
    </div>
    
    
      
        <span class="post-detail-header_date">
          <i class="fas fa-calendar"></i> Published in：2025-10-27 |
        </span>
      

      

      
    
  </div>
  
  
    <script defer src="/js/bubble/bubble.js"></script>
  
</div>





<div class="post-detail-content post-row" 
  style="padding-top: 0px;">
  <div class="main-content">
    <article class="post post-detail">
      <div class="post-content">
        <p>解决问题：从蛋白质结构生成序列</p>
<p>广泛适用于单体、环状低聚物、蛋白质纳米颗粒和蛋白质-蛋白质界面的设计。从消息传递神经网络 （MPNN） 开始，该网络具有 3 个编码器和 3 个解码器层以及 128 个隐藏维度，该网络使用蛋白质主链特征（Ca-Ca 原子之间的距离、相对 Ca-Ca-Ca 框架方向和旋转以及主链二面角）作为输入 （1），以自回归方式预测从 N 到 C 端的蛋白质序列。我们首先试图提高模型在给定其骨架结构的情况下恢复天然单体蛋白质氨基酸序列的性能，使用基于CATH（7）蛋白质分类的PDB分裂的19.7k高分辨率单链结构作为训练和验证集（参见方法）。我们尝试在 N、Ca、C、O 和基于其他主链原子放置的虚拟 Cb 之间添加距离作为附加输入特征，假设它们将比主链二面角特征实现更好的推理。这导致序列回收率从 41.2%（基线模型）增加到 49.0%（实验 1），见下表 1;原子间距离显然比二面角或 N-Ca-C 帧方向提供了更好的电感偏差来捕获残基之间的相互作用。接下来，我们尝试在主干编码器神经网络中引入边缘更新，以及节点更新（实验 2）。结合额外的输入特征和边缘更新可实现 50.5% 的序列恢复（实验 3）。为了确定主链几何形状影响氨基酸同一性的范围，我们对 16、24、32、48 和 64 个最近的 Ca 邻居神经网络进行了实验（图 S1A），发现性能在 32-48 个邻居处饱和。与蛋白质结构预测问题不同，局部连接图神经网络可用于对结构到序列映射问题进行建模，因为蛋白质主链提供了主要决定序列身份的局部邻域概念。</p>
<p><img src="/./img/proteinMPNN/p1.png" class="lazyload placeholder" data-srcset="/./img/proteinMPNN/p1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Table 1. Single chain sequence design performance on CATH held out test split. Test  accuracy (percentage of correct amino amino acids recovered) and test perplexity  (exponentiated categorical cross entropy loss per residue) are reported for models trained  on the native backbone coordinates (left, normal font) and models trained with Gaussian  noise (std=0.02Å) added to the backbone coordinates (right, bold font); all test evaluations  are with no added noise. The final column shows sequence recovery on 5,000 AlphaFold  protein backbone models with average pLDDT &gt; 80.0 randomly chosen from UniRef50  sequences."></p>
<p>指标包括：</p>
<p>ACC，即恢复原始序列的准确度</p>
<p>Perplexity，困惑度</p>
<p>AF ACC，即用生成的序列输入AF，生成的结构与原始结构的精确度</p>
<p>左边为原始骨架坐标输入，右边加粗为加入std&#x3D;0.02A的高斯噪声的训练结果</p>
<p>为了能够应用于广泛的单链和多链设计问题，我们用与顺序无关的自回归模型替换了固定的 N 到 C 端解码顺序，其中解码顺序是从所有可能排列的集合中随机采样的 （8）。这也导致序列恢复率略有改善（表1，实验4）。与顺序无关的解码可以在例如，蛋白质序列的中间是固定的，其余部分需要设计的情况下进行设计，例如在目标序列已知的蛋白质结合剂设计中;解码跳过固定区域，但将它们包含在其余位置的序列上下文中（图 1B）。对于多链设计问题，为了使模型与蛋白质链的顺序等变，我们将每链的相对位置编码上限为±32个残基（9），并添加了一个二进制特征，指示相互作用的残基对是来自相同链还是不同链。</p>
<p><img src="/./img/proteinMPNN/p2.png" class="lazyload placeholder" data-srcset="/./img/proteinMPNN/p2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Fig. 1. ProteinMPNN architecture. (A) Distances between N, Ca, C, O, and virtual Cb are  encoded and processed using a message passing neural network (Encoder) to obtain graph  node and edge features. The encoded features together with a partial sequence are used to  generate amino acids iteratively in a random decoding order. (B) A fixed left to right  decoding cannot use sequence context (green) for preceding positions (yellow) whereas a  model trained with random decoding orders can be used with arbitrary decoding order during  the inference. The decoding order can be chosen such that the fixed context is decoded first.  (C) Residue positions within and between chains can be tied together, enabling symmetric,  repeat protein, and multistate design. In this example, a homo-trimer is designed with  coupling of positions in different chains. Predicted logits for tied positions are averaged to  get a single probability distribution from which amino acids are sampled."></p>
<p>A）使用消息传递神经网络（Encoder）对N、Ca、C、O和虚拟Cb之间的距离进行编码和处理，以获得图节点和边缘特征。编码的特征与部分序列一起用于以随机解码顺序迭代生成氨基酸。（B）固定的从左到右解码不能对前面的位置（黄色）使用序列上下文（绿色），而使用随机解码顺序训练的模型可以在推理过程中使用任意解码顺序。可以选择解码顺序，以便首先解码固定上下文。 （C） 链内和链之间的残基位置可以连接在一起，从而实现对称、重复蛋白质和多状态设计。在本例中，同源三聚体被设计为不同链中位置的耦合。对并列位置的预测 logit 进行平均，以获得从中采样氨基酸的单一概率分布。</p>
<p>通过镜像对称的位点平均一下，采样同一个氨基酸</p>
<p><img src="/./img/proteinMPNN/p3.png" class="lazyload placeholder" data-srcset="/./img/proteinMPNN/p3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Fig. 2. In silico evaluation of ProteinMPNN. (A) ProteinMPNN has higher native sequence  recovery than Rosetta. The average Cb distance of the 8 closest neighbors (x axis) reports  on burial, with most buried positions on the left and more exposed on the right;  ProteinMPNN outperforms Rosetta at all levels of burial. Average sequence recovery for  ProteinMPNN was 52.4%, compared to 32.9% for Rosetta. (B) ProteinMPNN has similarly  high sequence recovery for monomers, homo-oligomers, and hetero-oligomers; violin plots  are for 690 monomers, 732 homomers, 98 heteromers. (C) Sequence recovery (black) and  relative AlphaFold success rates (blue) as a function of training noise level. For higher  accuracy predictions (circles) smaller amounts of noise are optimal (1.0 corresponds to 1.8%  success rate), while to maximize prediction success at a lower accuracy cutoff (squares),  models trained with more noise are better (1.0 corresponds to 6.7% success rate). (D)  Sequence recovery and diversity as a function of sampling temperature. Redesign of native  protein backbones with ProteinMPNN considerably increases AphaFold prediction accuracy compared to the original native sequence using no multiple sequence information. Single  sequences (designed or native) were input in both cases. (F) ProteinMPNN redesign of  previous Rosetta designed NTF2 fold proteins (3,000 backbones in total) results in  considerably improved AlphaFold single sequence prediction accuracy."></p>
<p>（A）ProteinMPNN比Rosetta具有更高的天然序列回收率。8个最近邻居的平均Cb距离（x轴）报告恢复情况，左侧恢复位置最多，右侧暴露较多; ProteinMPNN 在所有恢复级别都优于 Rosetta。ProteinMPNN 的平均序列恢复率为 52.4%，而 Rosetta 的平均序列恢复率为 32.9%。（B）ProteinMPNN对单体、同源寡聚物和异源寡聚物具有类似的高序列恢复率;小提琴图适用于 690 个单体、732 个同源体、98 个异构体。（C）序列恢复（黑色）和相对AlphaFold成功率（蓝色）作为训练噪声水平的函数。对于较高准确度的预测（圆圈），较小的噪声量是最佳的（1.0 对应于 1.8% 的成功率），而为了在较低的准确度截止值（正方形）下最大限度地提高预测成功率，使用更多噪声训练的模型更好（1.0 对应于 6.7% 的成功率）。（D）序列恢复和多样性随采样温度的变化。与使用无多序列信息的原始天然序列相比，使用 ProteinMPNN 重新设计天然蛋白质骨架可显着提高 AphaFold 预测准确性。在这两种情况下都输入了单个序列（设计的或天然的）。（F） 对先前 Rosetta 设计的 NTF2 折叠蛋白（总共 3,000 个主链）进行 ProteinMPNN 重新设计，从而显着提高了 AlphaFold 单序列预测精度。</p>
<p>使用主链噪声进行训练可提高蛋白质设计的模型性能</p>
<p>由于蛋白质表达、溶解度和功能的序列决定因素尚不完全清楚，因此在大多数蛋白质设计应用中，需要通过实验测试多个设计的序列。我们发现，通过在较高温度下进行推理，MPNN生成的序列多样性可以显着增加，平均序列回收率仅下降很小（图2D）。我们还发现，源自ProteinMPNN的序列质量测量，即给定结构的序列的平均对数概率，与在一定温度范围内的天然序列恢复率密切相关（图S3A），从而能够对序列进行快速排名以进行实验表征的选择。</p>
<p><img src="/./img/proteinMPNN/p4.png" class="lazyload placeholder" data-srcset="/./img/proteinMPNN/p4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Fig. 3. Structural characterization of ProteinMPNN designs. (A) Comparison of soluble  protein expression over a set of AlphaFold hallucinated monomers and homo-oligomers  (blue) and the same set of backbones with sequences designed using ProteinMPNN  (orange), N=129. The total soluble protein yield following expression in E. coli, obtained  from the integrated area unders size exclusion traces of nickel-NTA purified proteins,  increases considerably from the barely soluble protein of the original sequences following  ProteinMPNN rescue (median yields for 1 L of culture equivalent: 9 and 247 mg  respectively). (B), (C), (D) In depth characterization of a monomer hallucination and  corresponding ProteinMPNN rescue from the set in A. Like almost all of the designs in A, the sequence and structural similarity to the PDB of the design model are very low (E-value=2.8  against UniRef100 using HHblits, TM-score=0.56 against PDB). (B) The ProteinMPNN  rescued design has high thermostability, with a virtually unchanged circular dichroism profile  at 95 °C compared to 25 °C. (C) Size exclusion (SEC) profile of failed original design overlaid  with the ProteinMPNN sequence design, which has a clear monodisperse peak at the  expected retention volume. (D) Crystal structure of the ProteinMPNN (8CYK) design is  nearly identical to the design model (2.35 RMSD over 130 residues), see Figure S5 for  additional information. Right panel shows model sidechains in the electron density, in green  crystal side chains, in blue AlphaFold side chains. (E), (F) ProteinMPNN rescue of Rosetta  design made from a perfectly repeating structural and sequence unit (DHR82). Residues at  corresponding positions in the repeat unit were tied during ProteinMPNN sequence  inference. (E) Backbone design model and MPNN redesigned sequence AlphaFold model  with tied residues indicated by lines (~1.2Å error over 232 residues). (F) SEC profile of IMAC  purified original Rosetta design and two ProteinMPNN redesigns. (G), (H) Tying residues  during ProteinMPNN sequence inference both within and between chains to enforce both  repeat protein and cyclic symmetries. (G) Side view of design model. A set of tied residues  are shown in red. (H) Top-down view of design model. (I) Negative stain electron  micrograph of purified design. (J) Class average of images from I closely match top down  view in H. (K) Rescue of the failed two-component Rosetta tetrahedral nanoparticle design  T33-27 (13) by ProteinMPNN interface design. Following ProteinMPNN rescue, the  nanoparticle assembled readily with high yield, and the crystal structure (grey) is very nearly  identical to the design model (green/purple) (backbone RMSD of 1.2 Å over two complete  asymmetric units forming the ProteinMPNN rescued interface)."></p>
<p>（A）一组AlphaFold幻觉单体和同源寡聚体（蓝色）以及使用ProteinMPNN（橙色）设计序列的同一组骨架的可溶性蛋白表达的比较，N&#x3D;129。从镍-NTA纯化蛋白质的大小排除痕迹下的整合区域获得的大肠杆菌表达后的总可溶性蛋白质产量比ProteinMPNN拯救后原始序列的几乎不溶的蛋白质显着增加（1 L培养当量的中位产量：分别为9和247 mg）。（B）、（C）、（D） 单体幻觉的深入表征以及从 A 中的集合中拯救相应的 ProteinMPNN。与A中的几乎所有设计一样，设计模型的序列和结构相似性与PDB非常低（使用HHblits的UniRef100的E值&#x3D;2.8，PDB的TM分数&#x3D;0.56）。（B）ProteinMPNN拯救设计具有高热稳定性，与25 °C相比，在95 °C下圆二色性曲线几乎不变。 （C）与ProteinMPNN序列设计叠加的失败原始设计的尺寸排阻（SEC）曲线，在预期保留体积下具有明显的单分散峰。（D）ProteinMPNN（8CYK）设计的晶体结构与设计模型几乎相同（130个残基为2.35 RMSD），更多信息见图S5。右图显示了电子密度、绿色晶体侧链和蓝色 AlphaFold 侧链的模型侧链。（E）、（F）由完美重复的结构和序列单元（DHR82）制成的Rosetta设计的蛋白质MPNN救援。在 ProteinMPNN 序列推断期间，重复单元中相应位置的残基被绑定。（E）骨架设计模型和MPNN重新设计的序列AlphaFold模型，其连接残基由线表示（232个残基的~1.2Å误差）。（F）IMAC纯化的原始Rosetta设计和两个ProteinMPNN重新设计的SEC曲线。（G）、（H） 在链内和链之间的 ProteinMPNN 序列推断过程中连接残基，以强制执行重复蛋白质和循环对称性。（G）设计模型侧视图。一组捆绑的残基以红色显示。（H） 设计模型自上而下的视图。（I）纯化设计的负染色电子显微照片。（J） 来自 I 的图像的类平均值与 H 中的自上而下视图非常匹配。（K） 通过 ProteinMPNN 界面设计拯救失败的双组分 Rosetta 四面体纳米颗粒设计 T33-27 （13）。在 ProteinMPNN 救援后，纳米颗粒很容易组装，产量很高，晶体结构（灰色）与设计模型（绿色&#x2F;紫色）几乎相同（在形成 ProteinMPNN 救援界面的两个完整的不对称单元上，主链 RMSD 为 1.2 Å）。</p>
<p><img src="/./img/proteinMPNN/p5.png" class="lazyload placeholder" data-srcset="/./img/proteinMPNN/p5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Fig. 4. Design of protein function with ProteinMPNN. (A) Design scheme. First panel;  structure (PDB 2W0Z) of the peptide APPPRPPKP bound to the human Grb2 C-term SH3  domain (peptide is in green, target in surface and colored blue). Second panel: helical  bundle scaffolds were docked to the exposed face of the peptide using RIFDOCK (19), and  Rosetta remodel was used to build loops connecting the peptide to the scaffolds. Rosetta  sequence design with layer design task operations was used to optimize the sequence of the  fusion (Cyan) for stability, rigidity of the peptide-helical bundle interface, and binding affinity  for the Grb2 SH3 domain. Third panel; ProteinMPNN redesign (orange) of the designed  binder sequence; hydrogen bonds involving asparagine sidechains between the peptide and  base scaffold are shown in green and in the inset. Fourth panel; Mutation of the two  asparagines to aspartates to disrupt the scaffolding of the target peptide. (B) Experimental  characterization of binding using biolayer interferometry. Biotinylated C-term SH3 domain  from human Grb2 was loaded onto Streptavidin (SA) Biosensors, which were then  immersed in solutions containing varying concentrations of the target peptide (left) of the  designs (right panels), and then transferred to buffer lacking added protein for dissociation measurements. The MPNN design (3rd panel from the left) has much greater binding signal  than the original Rosetta design (2nd panel from the left); this is greatly reduced by the  asparagine to aspartate mutations (last panel)."></p>
<p>最后还评估了 ProteinMPNN 使用 Rosetta 挽救以前失败的新蛋白质功能设计的能力。</p>
<p>ProteinMPNN 在很短的时间内解决了序列设计问题（对于 100 个残基蛋白质，单个 CPU 为 1.2 秒，而单个 CPU 上为 258.8 秒），Rosetta 等基于物理的方法执行大规模侧链堆积计算，在天然骨架上实现了更高的蛋白质序列恢复率（52.4% 对 32.9%），最重要的是， 挽救了以前使用 Rosetta 或 AlphaFold 进行蛋白质单体、组装体和蛋白质-蛋白质界面的失败设计。以前已经开发了机器学习序列设计方法 （1-6），特别是前面描述的 ProteinMPNN 所基于的消息传递方法，但专注于单体设计问题，实现较低的天然序列恢复率，并且除了 TIM 桶设计研究 （6） 尚未使用晶体学和冷冻电镜进行广泛验证来评估设计准确性。虽然结构预测方法可以纯粹在计算机中进行评估，但蛋白质设计方法并非如此：计算机指标（例如天然序列回收）对晶体学分辨率非常敏感（图 S3 B、C），并且可能与适当的折叠（即使是单个残基替换，同时导致整体序列回收率变化很小）， 可以阻挡折叠）;就像语言翻译的准确性最终必须由人类用户评估一样，序列设计方法的最终测试是实验表征。 </p>
<p>与 Rosetta 和其他基于物理的方法不同，ProteinMPNN 不需要专家定制来应对特定的设计挑战，因此它应该使蛋白质设计更广泛地可访问。这种鲁棒性反映了序列设计问题构建方式的根本差异。在传统的基于物理的方法中，序列设计映射到识别其最低能态是所需结构的氨基酸序列的问题。然而，这在计算上是棘手的，因为它需要所有可能结构的计算能量，包括不需要的寡聚态和聚集态; 相反，Rosetta 和其他方法作为代理，为给定的主链结构搜索最低能量序列，并且在第二步中需要进行结构预测计算，以确认没有其他结构中该序列的能量仍然较低。由于实际设计目标与显式优化的内容之间缺乏一致性，因此可能需要大量的定制才能生成实际折叠的序列;例如，在 Rosetta 设计计算中，疏水氨基酸通常会受到蛋白质表面的限制，因为它们可以稳定不需要的多聚体状态，并且在蛋白质表面和核心之间的边界区域，对于应应用此类限制的程度可能存在相当大的模糊性。 虽然深度学习方法缺乏 Rosetta 等方法的物理透明度，但它们经过直接训练，可以在 PDB 中的所有示例中找到最可能的蛋白质主链氨基酸，因此不会出现这种歧义，使序列设计更加稳健，并且更少依赖人类专家的判断。 </p>
<p>ProteinMPNN 的实验设计成功率高，加上计算效率高、几乎适用于任何蛋白质序列设计问题以及无需定制，使其成为蛋白质设计研究所蛋白质序列设计的标准方法，我们预计它将在整个社区中迅速采用。如随附的论文（Wicky 等人）所示，ProteinMPNN 设计还具有更高的结晶倾向，极大地促进了设计蛋白质的结构测定。观察到，ProteinMPNN 生成的序列预计比原始天然序列更自信、更准确地折叠到天然蛋白质主链（在这两种情况下都使用单序列信息），这表明 ProteinMPNN 可能在改善重组表达的天然蛋白质的表达和稳定性方面具有广泛用途（功能所需的残基显然必须保持固定）。我们目前正在将 ProteinMPNN 扩展到蛋白质核酸设计和蛋白质小分子设计，这将进一步提高其实用性。</p>
<h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h3><p>对于表 1 中介绍的单链实验，我们使用了基于 CATH 4.2 40% 非冗余蛋白质集的数据集 （1， 7）。我们按照（1）中描述的设置训练模型，即使用原始Transformer论文（20）的学习率计划和初始化，10%的辍学率（21），10%的标签平滑率（22），具有6000个token的批量大小，使用Ca-Ca距离将图稀疏性设置为30个最近邻。</p>
<h3 id="损失函数和优化"><a href="#损失函数和优化" class="headerlink" title="损失函数和优化"></a>损失函数和优化</h3><p>我们使用负对数似然，标签平滑率为 10% （22） 来计算损失（不使用标签平滑也很有效）。负概率的总和比对数概率的平均值效果要好得多。训练损失由损失平均值 &#x3D; 总和（损失 * 掩码）&#x2F; 2000 定义，其中 2000 是根据经验选择的，损失（每个标记的分类交叉熵）和掩码具有形状 [批次，蛋白质长度]。为了进行优化，我们使用了 Adam，beta1 &#x3D; 0.9，beta2 &#x3D; 0.98，epsilon&#x3D; 10−9，以及 （20） 中描述的学习率计划。在单个 NVIDIA A100 GPU 上使用 pytorch （24）、10k 令牌的批量大小、自动混合精度和梯度检查点训练模型。作为优化器步骤函数的训练和验证损失（困惑度）如图 3D 所示。验证损失在大约 150k 优化器步骤后收敛，这是来自 23,358 个 PDB 集群的大约 100 个动态采样训练数据的 epoch。</p>
<h2 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h2><table>
<thead>
<tr>
<th>模块</th>
<th>作用</th>
<th>对应论文描述</th>
<th>输入&#x2F;输出维度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Featurize()</strong></td>
<td>将蛋白结构坐标转换为模型输入特征（节点、边、掩码等）</td>
<td>“Graph construction from backbone coordinates”</td>
<td>输出 <code>(X, S, mask, chain_M, residue_idx, ...)</code></td>
</tr>
<tr>
<td><strong>ProteinFeatures</strong></td>
<td>从坐标生成节点和边的几何特征，包括 RBF、相对位置、链信息</td>
<td>“Feature construction and geometric encoding”</td>
<td>输入 <code>(X[B,L,4,3])</code> → 输出边特征 <code>E[B,L,K,128]</code></td>
</tr>
<tr>
<td><strong>Encoder (EncLayer × 3)</strong></td>
<td>信息聚合层，对结构图做 message passing</td>
<td>“Structure encoder”</td>
<td>输入 <code>(h_V[B,L,128], h_E[B,L,K,128])</code></td>
</tr>
<tr>
<td><strong>Decoder (DecLayer × 3)</strong></td>
<td>自回归解码层，从掩码残基生成氨基酸分布</td>
<td>“Autoregressive sequence decoder”</td>
<td>输入 <code>(h_V, h_E, h_S)</code> → 输出 <code>log_probs[B,L,21]</code></td>
</tr>
<tr>
<td><strong>Output Layer (W_out)</strong></td>
<td>输出每个位置的氨基酸 logits</td>
<td>“Logits for amino acid types”</td>
<td><code>[B, L, 21]</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>Featurize(batch)</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>形状</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>X</code></td>
<td><code>[B, L, 4, 3]</code></td>
<td>每个残基的原子坐标（N, CA, C, O）</td>
</tr>
<tr>
<td><code>S</code></td>
<td><code>[B, L]</code></td>
<td>氨基酸种类（整数索引）</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>[B, L]</code></td>
<td>1 表示有效残基</td>
</tr>
<tr>
<td><code>chain_M</code></td>
<td><code>[B, L]</code></td>
<td>1 表示要预测的残基（masked chain）</td>
</tr>
<tr>
<td><code>residue_idx</code></td>
<td><code>[B, L]</code></td>
<td>全局残基索引（跨链连续编号）</td>
</tr>
<tr>
<td><code>chain_encoding_all</code></td>
<td><code>[B, L]</code></td>
<td>链 ID（整数编码）</td>
</tr>
</tbody></table>
<ul>
<li><strong>图构建与几何编码：<code>ProteinFeatures</code></strong></li>
</ul>
<p>输入：<code>X (B,L,4,3)</code><br>输出：</p>
<ul>
<li><code>E</code>: <code>[B, L, K, edge_dim=128]</code></li>
<li><code>E_idx</code>: <code>[B, L, K]</code>  邻居索引（top-K 最近邻）</li>
</ul>
<p>核心步骤：</p>
<ol>
<li>计算 <strong>Cα–Cα</strong> 距离矩阵；</li>
<li>选取每个残基的 top-K 近邻；</li>
<li>计算 25 种不同原子对之间的径向基函数（RBF）特征（例如 N–N, C–C, O–O, Cα–Cb, 等）；<ul>
<li>每种原子对产生 <code>num_rbf=16</code> 维 → 总计 <code>25×16 = 400</code>；</li>
</ul>
</li>
<li>计算残基的相对顺序偏移（offset embedding, 约 65 维）；</li>
<li>拼接后通过线性层 → <code>edge_features=128</code>；</li>
<li>LayerNorm。</li>
</ol>
<blockquote>
<p>输出的边特征 E 就是图的连接权重，用于 message passing。</p>
</blockquote>
<ul>
<li><strong>Encoder（结构编码器）</strong></li>
</ul>
<p>输入：</p>
<ul>
<li>节点初始特征 <code>h_V = zeros([B,L,128])</code></li>
<li>边特征线性映射 <code>h_E = W_e(E)</code> → <code>[B,L,K,128]</code></li>
</ul>
<h4 id="EncLayer-内部结构："><a href="#EncLayer-内部结构：" class="headerlink" title="EncLayer 内部结构："></a>EncLayer 内部结构：</h4><ul>
<li><p>输入：</p>
<ul>
<li>节点：<code>h_V [B,L,128]</code></li>
<li>边：<code>h_E [B,L,K,128]</code></li>
</ul>
</li>
<li><p>拼接后：<code>h_EV = concat(h_V_i, h_E_ij, h_V_j)</code> → <code>[B,L,K,256]</code></p>
</li>
<li><p>线性层序列：<code>W1 → W2 → W3</code>（每层输出 128）</p>
</li>
<li><p>残差 + LayerNorm + Dropout</p>
</li>
<li><p>FeedForward (128→512→128)</p>
</li>
<li><p>输出：更新后的 <code>h_V, h_E</code>，形状不变 <code>[B,L,128]</code>, <code>[B,L,K,128]</code></p>
</li>
<li><p><strong>Decoder（自回归解码器）</strong></p>
<p>输入：</p>
<ul>
<li>结构编码后的 <code>h_V</code>（来自 encoder）</li>
<li>边特征 <code>h_E</code></li>
<li>已知序列嵌入 <code>h_S = Embedding(S)</code> → <code>[B,L,128]</code></li>
</ul>
</li>
</ul>
<p>流程：</p>
<ol>
<li><p>拼接邻居节点和边：<br> <code>h_ES = cat_neighbors_nodes(h_S, h_E, E_idx)</code> → <code>[B,L,K,256]</code></p>
</li>
<li><p>生成自回归掩码：</p>
<ul>
<li>随机打乱 masked 残基顺序；</li>
<li>构造前向（mask_fw）和后向（mask_bw）掩码；</li>
</ul>
</li>
<li><p>结合结构编码结果：<br> <code>h_EXV_encoder_fw = mask_fw * h_EXV_encoder</code></p>
</li>
<li><p>多层解码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(3):</span><br><span class="line">    h_ESV = cat_neighbors_nodes(h_V, h_ES, E_idx)</span><br><span class="line">    h_ESV = mask_bw * h_ESV + h_EXV_encoder_fw</span><br><span class="line">    h_V = DecLayer(h_V, h_ESV)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出 logits：<br> <code>logits = W_out(h_V)</code> → <code>[B, L, 21]</code><br> <code>log_probs = log_softmax(logits)</code></p>
</li>
</ol>
<h4 id="内部结构："><a href="#内部结构：" class="headerlink" title="内部结构："></a>内部结构：</h4><p>与 EncLayer 类似，但更简单：</p>
<ul>
<li><p>只更新节点向量；</p>
</li>
<li><p>输入 <code>[B,L,128]</code>，输出 <code>[B,L,128]</code>；</p>
</li>
<li><p>内含 3 个线性层 + GELU + 残差 + LayerNorm；</p>
</li>
<li><p>FeedForward (128→512→128)。</p>
</li>
<li><p><strong>输出层与损失</strong></p>
</li>
</ul>
<p>输出：</p>
<ul>
<li><code>log_probs</code>: <code>[B, L, 21]</code></li>
</ul>
<p>损失函数：</p>
<ul>
<li><code>loss_nll</code>: 负对数似然 NLL（每个残基的氨基酸预测概率）</li>
<li><code>loss_smoothed</code>: 带 label smoothing 的版本</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>形状</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>X</code></td>
<td><code>[B, L_max, 4, 3]</code></td>
<td>float tensor</td>
<td>每个残基 N,CA,C,O 的 xyz；pad 部分被置 0，但 <code>mask</code> 标记为 0</td>
</tr>
<tr>
<td><code>S</code></td>
<td><code>[B, L_max]</code></td>
<td>long tensor</td>
<td>序列标签（整型索引），pad 为 0</td>
</tr>
<tr>
<td><code>mask</code></td>
<td><code>[B, L_max]</code></td>
<td>float tensor</td>
<td>1.0 表示该位置有真实坐标（可用于计算），0.0 表示 pad</td>
</tr>
<tr>
<td><code>lengths</code></td>
<td><code>[B]</code></td>
<td>numpy int</td>
<td>每个样本的真实长度</td>
</tr>
<tr>
<td><code>chain_M</code></td>
<td><code>[B, L_max]</code></td>
<td>float tensor</td>
<td>1.0 &#x3D; 该位置需要被模型预测（masked），0.0 &#x3D; visible（已知）</td>
</tr>
<tr>
<td><code>residue_idx</code></td>
<td><code>[B, L_max]</code></td>
<td>long tensor</td>
<td>全局残基索引（含链间跳跃），用于构造相对位置&#x2F;offset</td>
</tr>
<tr>
<td><code>mask_self</code></td>
<td><code>[B, L_max, L_max]</code></td>
<td>float tensor</td>
<td>0 表示同链内部（不算作 interface），1 表示可能的跨链交互（用于 interface loss）</td>
</tr>
<tr>
<td><code>chain_encoding_all</code></td>
<td><code>[B, L_max]</code></td>
<td>long tensor</td>
<td>链编号（整数），用于 chain-aware embedding&#x2F;特征</td>
</tr>
</tbody></table>
<p><strong>N, CA, C, O 四原子</strong>：这些主链原子能完整表示主链几何（主链走向与局部平面），后续网络会基于这些构建 <code>Cβ</code>（代码在 <code>ProteinFeatures</code> 中用叉积估计虚拟 Cβ）并计算多种原子对的 RBF 特征。把原子顺序固定（N,CA,C,O）确保后面的几何计算一致。</p>
<p><strong>用 NaN 做 padding</strong>：方便直接通过 <code>isfinite</code> 检测有效位置然后再统一填 0，避免对后续几何计算产生不合理偏移。</p>
<p><strong><code>residue_idx</code> 带链跳跃</strong>：在计算相对位置（offset）时能够区分“同链但不同位置”与“跨链”场景（特别对对称&#x2F;多链任务很重要）。</p>
<p><strong><code>chain_M</code> 与随机链顺序</strong>：随机打乱链顺序 + chain mask 可以训练模型去适应不同链排列与部分已知&#x2F;部分未知的场景（即 order-agnostic decoding）。</p>
<p>**<code>mask_self</code>**：为 interface 专门做的掩码，后面计算 interface loss 时通常只想考虑跨链相互作用，不希望把同链内部也计入。</p>
<p>&#x3D;&#x3D; 模型结构信息 &#x3D;&#x3D;<br>模块: features, 类型: ProteinFeatures<br>模块: W_e, 类型: Linear<br>模块: W_s, 类型: Embedding<br>模块: encoder_layers, 类型: ModuleList<br>模块: decoder_layers, 类型: ModuleList<br>模块: W_out, 类型: Linear</p>
<p>&#x3D;&#x3D; 可训练参数详情 &#x3D;&#x3D;<br>可训练: features.embeddings.linear.weight, 形状: torch.Size([16, 66]), 参数量: 1,056<br>可训练: features.embeddings.linear.bias, 形状: torch.Size([16]), 参数量: 16<br>可训练: features.edge_embedding.weight, 形状: torch.Size([128, 416]), 参数量: 53,248<br>可训练: features.norm_edges.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: features.norm_edges.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: W_e.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: W_e.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: W_s.weight, 形状: torch.Size([21, 128]), 参数量: 2,688<br>可训练: encoder_layers.0.norm1.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.norm1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.norm2.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.norm2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.norm3.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.norm3.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.W1.weight, 形状: torch.Size([128, 384]), 参数量: 49,152<br>可训练: encoder_layers.0.W1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.W2.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.0.W2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.W3.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.0.W3.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.W11.weight, 形状: torch.Size([128, 384]), 参数量: 49,152<br>可训练: encoder_layers.0.W11.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.W12.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.0.W12.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.W13.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.0.W13.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.0.dense.W_in.weight, 形状: torch.Size([512, 128]), 参数量: 65,536<br>可训练: encoder_layers.0.dense.W_in.bias, 形状: torch.Size([512]), 参数量: 512<br>可训练: encoder_layers.0.dense.W_out.weight, 形状: torch.Size([128, 512]), 参数量: 65,536<br>可训练: encoder_layers.0.dense.W_out.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.norm1.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.norm1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.norm2.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.norm2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.norm3.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.norm3.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.W1.weight, 形状: torch.Size([128, 384]), 参数量: 49,152<br>可训练: encoder_layers.1.W1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.W2.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.1.W2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.W3.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.1.W3.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.W11.weight, 形状: torch.Size([128, 384]), 参数量: 49,152<br>可训练: encoder_layers.1.W11.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.W12.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.1.W12.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.W13.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.1.W13.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.1.dense.W_in.weight, 形状: torch.Size([512, 128]), 参数量: 65,536<br>可训练: encoder_layers.1.dense.W_in.bias, 形状: torch.Size([512]), 参数量: 512<br>可训练: encoder_layers.1.dense.W_out.weight, 形状: torch.Size([128, 512]), 参数量: 65,536<br>可训练: encoder_layers.1.dense.W_out.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.norm1.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.norm1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.norm2.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.norm2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.norm3.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.norm3.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.W1.weight, 形状: torch.Size([128, 384]), 参数量: 49,152<br>可训练: encoder_layers.2.W1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.W2.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.2.W2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.W3.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.2.W3.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.W11.weight, 形状: torch.Size([128, 384]), 参数量: 49,152<br>可训练: encoder_layers.2.W11.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.W12.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.2.W12.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.W13.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: encoder_layers.2.W13.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: encoder_layers.2.dense.W_in.weight, 形状: torch.Size([512, 128]), 参数量: 65,536<br>可训练: encoder_layers.2.dense.W_in.bias, 形状: torch.Size([512]), 参数量: 512<br>可训练: encoder_layers.2.dense.W_out.weight, 形状: torch.Size([128, 512]), 参数量: 65,536<br>可训练: encoder_layers.2.dense.W_out.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.0.norm1.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.0.norm1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.0.norm2.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.0.norm2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.0.W1.weight, 形状: torch.Size([128, 512]), 参数量: 65,536<br>可训练: decoder_layers.0.W1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.0.W2.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: decoder_layers.0.W2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.0.W3.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: decoder_layers.0.W3.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.0.dense.W_in.weight, 形状: torch.Size([512, 128]), 参数量: 65,536<br>可训练: decoder_layers.0.dense.W_in.bias, 形状: torch.Size([512]), 参数量: 512<br>可训练: decoder_layers.0.dense.W_out.weight, 形状: torch.Size([128, 512]), 参数量: 65,536<br>可训练: decoder_layers.0.dense.W_out.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.1.norm1.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.1.norm1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.1.norm2.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.1.norm2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.1.W1.weight, 形状: torch.Size([128, 512]), 参数量: 65,536<br>可训练: decoder_layers.1.W1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.1.W2.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: decoder_layers.1.W2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.1.W3.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: decoder_layers.1.W3.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.1.dense.W_in.weight, 形状: torch.Size([512, 128]), 参数量: 65,536<br>可训练: decoder_layers.1.dense.W_in.bias, 形状: torch.Size([512]), 参数量: 512<br>可训练: decoder_layers.1.dense.W_out.weight, 形状: torch.Size([128, 512]), 参数量: 65,536<br>可训练: decoder_layers.1.dense.W_out.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.2.norm1.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.2.norm1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.2.norm2.weight, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.2.norm2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.2.W1.weight, 形状: torch.Size([128, 512]), 参数量: 65,536<br>可训练: decoder_layers.2.W1.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.2.W2.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: decoder_layers.2.W2.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.2.W3.weight, 形状: torch.Size([128, 128]), 参数量: 16,384<br>可训练: decoder_layers.2.W3.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: decoder_layers.2.dense.W_in.weight, 形状: torch.Size([512, 128]), 参数量: 65,536<br>可训练: decoder_layers.2.dense.W_in.bias, 形状: torch.Size([512]), 参数量: 512<br>可训练: decoder_layers.2.dense.W_out.weight, 形状: torch.Size([128, 512]), 参数量: 65,536<br>可训练: decoder_layers.2.dense.W_out.bias, 形状: torch.Size([128]), 参数量: 128<br>可训练: W_out.weight, 形状: torch.Size([21, 128]), 参数量: 2,688<br>可训练: W_out.bias, 形状: torch.Size([21]), 参数量: 21</p>

      </div>
      <div class="post-tags-categories">
        
      </div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      <!-- 文章详情页的上一页和下一页 -->
<div class="post-nav">





  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://raw.githubusercontent.com/ai4protein/VenusREM/main/img/framework.png" class="lazyload placeholder" data-srcset="https://raw.githubusercontent.com/ai4protein/VenusREM/main/img/framework.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" src="" alt="">
    </div>
    <a href="/2025/10/23/venusREM/" class="post-nav-link">
      <div class="title">
        Next: <i class="fas fa-angle-right"></i>
        <div class="title-text">【文献阅读】VenusREM</div>
      </div>
      <!-- <div class="content">
        动机：酶工程是通过修饰野生型蛋白质来增强催化活性和热稳定性等特性来生产满足工业和研究需求的酶的关键方法。除了传统的定向进
      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    

    <!-- 分享 -->
    
    
    <!-- 评论 -->
    <!-- 评论 -->

  <div id="myComment">
    
      <div id="gitment-container"></div>

    
  </div>


<!-- 还需要在后面这个地址里设置script, comment script in themes\hexo-theme-bamboo\layout\_partial\scripts\index.ejs -->


  </div>

  <!-- 目录 -->
  <aside id='l_side'>
  
    
      <section class="widget side_blogger">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/index'>
          <img src='/img/Kaz.jpg'/>
        </a>
      
    
    
      <div class='text'>
        
          <h2>Kaz</h2>
        
        
          <p>好戏都在烟火里</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:alanluo233@gmail.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="https://github.com/HuoYu233"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=1981270473"
              class="social fab fa-qq flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
          
            <a href="https://space.bilibili.com/82505737"
              class="social fab fa-bilibili flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
              
            </a>
          
        
      </div>
    
  </div>
</section>

    
  
  
  

  <div class="layout_sticky">    
    
      
<section class="widget side_toc">
  
  <header>
    
      <i style="color: " class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name' style="color: ">本文目录</span>
    
  </header>


  <div class='content'>
    <div class="toc-main">
      <div class="toc-content">
        <!-- <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Methods"><span class="toc-text">Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE"><span class="toc-text">训练数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-text">损失函数和优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84"><span class="toc-text">模型架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EncLayer-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">EncLayer 内部结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">内部结构：</span></a></li></ol></li></ol></li></ol> -->
        <div class="toc"></div>
      </div>
    </div>
  </div>
</section>
<!-- 手机端目录按钮 -->
<div id="toc-mobile-btn">
  <i class="fas fa-list-ul" aria-hidden="true"></i>
</div>

      
    
  </div>
</aside>

  <!-- 图片放大 Wrap images with fancybox support -->
  <script defer src="/js/wrapImage.js"></script>
</div>

<!-- 文章详情页背景图 -->
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;"
	:style="{'background-color': bgColor ? bgColor : 'transparent'}">
	<transition-group tag="ul" :name="names">
		<li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
			<img :src="image" class="bg-swiper-img no-lazy">
		</li>
	</transition-group>
</div>
<script>
	var vm = new Vue({
		el: '#appBgSwiper',
		data: {
			names: '' || 'fade' || 'fade', // translate-fade fade
			mark: 0,
			img: [],
			bgColor: '',
			time: null
		},
		methods: {   //添加方法
			change(i, m) {
				if (i > m) {
					// this.names = 'fade';
				} else if (i < m) {
					// this.names = 'fade';
				} else {
					return;
				}
				this.mark = i;
			},
			prev() {
				// this.names = 'fade';
				this.mark--;
				if (this.mark === -1) {
					this.mark = 3;
					return
				}
			},
			next() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			autoPlay() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			play() {
				let bgImgDelay = '' || '180000'
				let delay = parseInt(bgImgDelay) || 180000;
				this.time = setInterval(this.autoPlay, delay);
			},
			enter() {
				clearInterval(this.time);
			},
			leave() {
				this.play();
			}
		},
		created() {
			this.play()
		},
		beforeDestroy() {
			clearInterval(this.time);
		},
		mounted() {
			let prop = '' || '';
			let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://')
			if (isImg) {
				let img = prop.split(',');
				let configRoot = '/'
				let arrImg = [];
				img.forEach(el => {
					var Expression = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
					var objExp = new RegExp(Expression);

					if (objExp.test(el)) {
						// http or https
						arrImg.push(el);
					} else {
						// 非http or https开头
						// 本地文件
						let firstStr = el.charAt(0);
						if (firstStr == '/') {
							el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
						}
						el = configRoot + el;
						arrImg.push(el);
					}
				})
				this.img = arrImg;
			} else {
				this.bgColor = prop;
			}
		}
	})
</script>

<style>
	.bg-swiper-box {
		position: absolute;
		display: block;
		width: 100%;
		height: 100%;
	}

	.bg-swiper-img {
		object-fit: cover;
		width: 100%;
		height: 100%;
	}
</style>


  <script>
  // https://github.com/theme-next/hexo-theme-next/blob/master/layout/_third-party/math/mathjax.swig
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://unpkg.com/mathjax@3.0/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    // 文章章节标题不能为 “MathJax” ，否则会报错。
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>




  <script>
  function loadMermaid() {
    if (document.getElementsByClassName('mermaid').length) {
      if (window.mermaidJsLoad) mermaid.init()
      else {
        loadScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
          window.mermaidJsLoad = true
          mermaid.initialize({
            theme: 'default',
          })
          if ('true') {
            mermaid.init();
          }
        })
      }
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    loadMermaid();
  })

  document.addEventListener('pjax:complete', function () {
    loadMermaid();
  })
  
</script>


      </main>
    </div>

    <!-- 页脚 -->
    
  
  
    <!-- 底部鱼儿跳动效果，依赖于jquery-->
<div id="j-fish-skip" style=" position: relative;height: 153px;width: auto;"></div>
<script defer>
  var RENDERER = {
    POINT_INTERVAL: 5,
    FISH_COUNT: 3,
    MAX_INTERVAL_COUNT: 50,
    INIT_HEIGHT_RATE: .5,
    THRESHOLD: 50,
    FISH_COLOR: '',
    init: function () {
      this.setFishColor(); this.setParameters(), this.reconstructMethods(), this.setup(), this.bindEvent(), this.render()
    },
    setFishColor: function () {
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
      if (isDark) {
        this.FISH_COLOR = '#222'; // 暗黑色，有时间把这整成一个变量
      } else {
        this.FISH_COLOR = '' || 'rgba(173, 216, 230, 0.8)';
      }
    },
    setParameters: function () {
      this.$window = $(window), this.$container = $("#j-fish-skip"), this.$canvas = $("<canvas />"), this.context = this.$canvas.appendTo(this.$container).get(0).getContext("2d"), this.points = [], this.fishes = [], this.watchIds = []
    },
    createSurfacePoints: function () {
      var t = Math.round(this.width / this.POINT_INTERVAL);
      this.pointInterval = this.width / (t - 1), this.points.push(new SURFACE_POINT(this, 0));
      for (var i = 1; i < t; i++) {
        var e = new SURFACE_POINT(this, i * this.pointInterval),
          h = this.points[i - 1];
        e.setPreviousPoint(h), h.setNextPoint(e), this.points.push(e)
      }
    },
    reconstructMethods: function () {
      this.watchWindowSize = this.watchWindowSize.bind(this), this.jdugeToStopResize = this.jdugeToStopResize.bind(this), this.startEpicenter = this.startEpicenter.bind(this), this.moveEpicenter = this.moveEpicenter.bind(this), this.reverseVertical = this.reverseVertical.bind(this), this.render = this.render.bind(this)
    },
    setup: function () {
      this.points.length = 0, this.fishes.length = 0, this.watchIds.length = 0, this.intervalCount = this.MAX_INTERVAL_COUNT, this.width = this.$container.width(), this.height = this.$container.height(), this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500, this.$canvas.attr({
        width: this.width,
        height: this.height
      }), this.reverse = !1, this.fishes.push(new FISH(this)), this.createSurfacePoints()
    },
    watchWindowSize: function () {
      this.clearTimer(), this.tmpWidth = this.$window.width(), this.tmpHeight = this.$window.height(), this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL))
    },
    clearTimer: function () {
      for (; this.watchIds.length > 0;) clearTimeout(this.watchIds.pop())
    },
    jdugeToStopResize: function () {
      var t = this.$window.width(),
        i = this.$window.height(),
        e = t == this.tmpWidth && i == this.tmpHeight;
      this.tmpWidth = t, this.tmpHeight = i, e && this.setup()
    },
    bindEvent: function () {
      this.$window.on("resize", this.watchWindowSize), this.$container.on("mouseenter", this.startEpicenter), this.$container.on("mousemove", this.moveEpicenter)
    },
    getAxis: function (t) {
      var i = this.$container.offset();
      return {
        x: t.clientX - i.left + this.$window.scrollLeft(),
        y: t.clientY - i.top + this.$window.scrollTop()
      }
    },
    startEpicenter: function (t) {
      this.axis = this.getAxis(t)
    },
    moveEpicenter: function (t) {
      var i = this.getAxis(t);
      this.axis || (this.axis = i), this.generateEpicenter(i.x, i.y, i.y - this.axis.y), this.axis = i
    },
    generateEpicenter: function (t, i, e) {
      if (!(i < this.height / 2 - this.THRESHOLD || i > this.height / 2 + this.THRESHOLD)) {
        var h = Math.round(t / this.pointInterval);
        h < 0 || h >= this.points.length || this.points[h].interfere(i, e)
      }
    },
    reverseVertical: function () {
      this.reverse = !this.reverse;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].reverseVertical()
    },
    controlStatus: function () {
      for (var t = 0, i = this.points.length; t < i; t++) this.points[t].updateSelf();
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].updateNeighbors();
      this.fishes.length < this.fishCount && 0 == --this.intervalCount && (this.intervalCount = this.MAX_INTERVAL_COUNT, this.fishes.push(new FISH(this)))
    },
    render: function () {
      requestAnimationFrame(this.render), this.controlStatus(), this.context.clearRect(0, 0, this.width, this.height), this.context.fillStyle = this.FISH_COLOR;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].render(this.context);
      this.context.save(), this.context.globalCompositeOperation = "xor", this.context.beginPath(), this.context.moveTo(0, this.reverse ? 0 : this.height);
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].render(this.context);
      this.context.lineTo(this.width, this.reverse ? 0 : this.height), this.context.closePath(), this.context.fill(), this.context.restore()
    }
  },
  SURFACE_POINT = function (t, i) {
    this.renderer = t, this.x = i, this.init()
  };
  SURFACE_POINT.prototype = {
    SPRING_CONSTANT: .03,
    SPRING_FRICTION: .9,
    WAVE_SPREAD: .3,
    ACCELARATION_RATE: .01,
    init: function () {
      this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE, this.height = this.initHeight, this.fy = 0, this.force = {
        previous: 0,
        next: 0
      }
    },
    setPreviousPoint: function (t) {
      this.previous = t
    },
    setNextPoint: function (t) {
      this.next = t
    },
    interfere: function (t, i) {
      this.fy = this.renderer.height * this.ACCELARATION_RATE * (this.renderer.height - this.height - t >= 0 ? -1 : 1) * Math.abs(i)
    },
    updateSelf: function () {
      this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height), this.fy *= this.SPRING_FRICTION, this.height += this.fy
    },
    updateNeighbors: function () {
      this.previous && (this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height)), this.next && (this.force.next = this.WAVE_SPREAD * (this.height - this.next.height))
    },
    render: function (t) {
      this.previous && (this.previous.height += this.force.previous, this.previous.fy += this.force.previous), this.next && (this.next.height += this.force.next, this.next.fy += this.force.next), t.lineTo(this.x, this.renderer.height - this.height)
    }
  };
  var FISH = function (t) {
    this.renderer = t, this.init()
  };
  FISH.prototype = {
    GRAVITY: .4,
    init: function () {
      this.direction = Math.random() < .5, this.x = this.direction ? this.renderer.width + this.renderer.THRESHOLD : -this.renderer.THRESHOLD, this.previousY = this.y, this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1), this.renderer.reverse ? (this.y = this.getRandomValue(1 * this.renderer.height / 10, 4 * this.renderer.height / 10), this.vy = this.getRandomValue(2, 5), this.ay = this.getRandomValue(.05, .2)) : (this.y = this.getRandomValue(6 * this.renderer.height / 10, 9 * this.renderer.height / 10), this.vy = this.getRandomValue(-5, -2), this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1, this.theta = 0, this.phi = 0
    },
    getRandomValue: function (t, i) {
      return t + (i - t) * Math.random()
    },
    reverseVertical: function () {
      this.isOut = !this.isOut, this.ay *= -1
    },
    controlStatus: function (t) {
      this.previousY = this.y, this.x += this.vx, this.y += this.vy, this.vy += this.ay, this.renderer.reverse ? this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy -= this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(.05, .2)), this.isOut = !1) : this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy += this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1), this.isOut || (this.theta += Math.PI / 20, this.theta %= 2 * Math.PI, this.phi += Math.PI / 30, this.phi %= 2 * Math.PI), this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY), (this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD) && this.init()
    },
    render: function (t) {
      t.save(), t.translate(this.x, this.y), t.rotate(Math.PI + Math.atan2(this.vy, this.vx)), t.scale(1, this.direction ? 1 : -1), t.beginPath(), t.moveTo(-30, 0), t.bezierCurveTo(-20, 15, 15, 10, 40, 0), t.bezierCurveTo(15, -10, -20, -15, -30, 0), t.fill(), t.save(), t.translate(40, 0), t.scale(.9 + .2 * Math.sin(this.theta), 1), t.beginPath(), t.moveTo(0, 0), t.quadraticCurveTo(5, 10, 20, 8), t.quadraticCurveTo(12, 5, 10, 0), t.quadraticCurveTo(12, -5, 20, -8), t.quadraticCurveTo(5, -10, 0, 0), t.fill(), t.restore(), t.save(), t.translate(-3, 0), t.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)), t.beginPath(), this.renderer.reverse ? (t.moveTo(5, 0), t.bezierCurveTo(10, 10, 10, 30, 0, 40), t.bezierCurveTo(-12, 25, -8, 10, 0, 0)) : (t.moveTo(-5, 0), t.bezierCurveTo(-10, -10, -10, -30, 0, -40), t.bezierCurveTo(12, -25, 8, -10, 0, 0)), t.closePath(), t.fill(), t.restore(), t.restore(), this.controlStatus(t)
    }
  }, $(function () {
    RENDERER.init()
    $('.dark').click(function () {
      setTimeout(() => {
        RENDERER.setFishColor();
        RENDERER.context.fill();
      });
    })
  });
</script>
  
  <div class="footer bg-color">
    <div class="footer-main">
      
        
          <div class="link">
            
          </div>
        
      
        
          <div class="footer-copyright">
            <p>Copyright © 2023 - 2025 <a target="_blank" rel="noopener" href="https://github.com/HuoYu233">Kaz</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> </p>

          </div>
        
      
        
          <div class="footer-custom">
            
          </div>
        
      
    </div>
  </div>



    <!-- 渲染暗黑按钮 -->
    
      <div class="dark" onclick="toggleDarkMode()">
  <div class="dark-content">
    <i class="fas" id="darkIcon" aria-hidden="true"></i>
  </div>
</div>

<script defer>
  $(function() {
    // 初始化暗黑模式状态
    let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
    updateDarkModeIcon(isDark);
  });

  function toggleDarkMode() {
    const isDark = $(document.body).hasClass('darkModel');
    $(document.body).toggleClass('darkModel');
    localStorage.setItem('dark', !isDark);
    updateDarkModeIcon(!isDark);
  }

  function updateDarkModeIcon(isDark) {
    const iconElement = document.getElementById('darkIcon');
    if (isDark) {
      iconElement.classList.remove('fa-moon');
      iconElement.classList.add('fa-lightbulb');
    } else {
      iconElement.classList.remove('fa-lightbulb');
      iconElement.classList.add('fa-moon');
    }
  }
</script>

    
    <!-- 渲染回到顶部按钮 -->
    
      <div class="goTop top-btn-color" pointer>
  <i class="fas fa-arrow-up" aria-hidden="true"></i>
</div>
<script defer src="/js/goTop.js"></script>

    
    <!-- 渲染左下角音乐播放器 -->
    

    <!-- 图片放大 -->
    
      <script src="https://unpkg.com/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js"></script>
    

    <!-- 百度解析 -->
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script async>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <!-- 背景彩带 -->
    

    <script src="/js/utils/index.js"></script>
    <script src="/js/app.js"></script>
    
    <!-- 文章目录所需js -->
<!-- <link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">

<script>
  var headerEl = 'h2, h3, h4',  //headers 
    content = '.post-detail',//文章容器
    idArr = {};  //标题数组以确定是否增加索引id
  //add #id
  var option = {
    // Where to render the table of contents.
    tocSelector: '.toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: content,
    // Which headings to grab inside of the contentSelector element.
    headingSelector: headerEl,
    scrollSmooth: true,
    scrollSmoothOffset: -70,
    // headingsOffset: -($(window).height() * 0.4 - 45),
    headingsOffset: -($(window).height() * 0.4 - 70),
    // positionFixedSelector: '.toc-main',
    // positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    activeLinkClass: 'is-active-link',
    orderedList: true,
    collapseDepth: 20,
    // onClick: function (e) {},
  }
  if ($('.toc').length > 0) {

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      tocbot.init(option);
      mobileTocClick();
    });

  }

  window.tocScrollFn = function () {
    return bamboo.throttle(function () {
      findHeadPosition();
    }, 100)()
  }
  window.addEventListener('scroll', tocScrollFn);

  const findHeadPosition = function (top) {
    if ($('.toc-list').length <= 0) {
      return false;
    }
    setTimeout(() => {  // or DOMContentLoaded 
      autoScrollToc();
    }, 0);
  }

  const autoScrollToc = function () {
    const $activeItem = document.querySelector('.is-active-link');
    const $cardToc = document.querySelector('.toc-content');
    const activePosition = $activeItem.getBoundingClientRect().top
    const sidebarScrollTop = $cardToc.scrollTop
    if (activePosition > (document.documentElement.clientHeight - 100)) {
      $cardToc.scrollTop = sidebarScrollTop + 150
    }
    if (activePosition < 150) {
      $cardToc.scrollTop = sidebarScrollTop - 150
    }
  }

  document.addEventListener('pjax:send', function () {
    if ($('.toc').length) {
      tocbot.destroy();
    }
  });

  document.addEventListener('pjax:complete', function () {
    if ($('.toc').length) {
      tocbot.init(option);
      mobileTocClick();
    }
  });
  
  // 手机端toc按钮点击出现目录
  const mobileTocClick = function () {
    const $cardTocLayout = document.getElementsByClassName('side_toc')[0];
    const $cardToc = $cardTocLayout.getElementsByClassName('toc-content')[0];
    let right = '45px';
    if (window.innerWidth >= 551 && window.innerWidth <= 992) {
      right = '100px'
    }
    const mobileToc = {
      open: () => {
        $cardTocLayout.style.cssText = 'animation: toc-open .3s; opacity: 1; right: ' + right
      },

      close: () => {
        $cardTocLayout.style.animation = 'toc-close .2s'
        setTimeout(() => {
          $cardTocLayout.style.cssText = "opacity:''; animation: ''; right: ''"
        }, 100)
      }
    }
    document.getElementById('toc-mobile-btn').addEventListener('click', () => {
      if (window.getComputedStyle($cardTocLayout).getPropertyValue('opacity') === '0') mobileToc.open()
      else mobileToc.close()
    })

    $cardToc.addEventListener('click', (e) => {
      if (window.innerWidth < 992) { // 小于992px的时候
        mobileToc.close()
      }
    })
  }
</script>

<style>
  /* .is-position-fixed {
    position: sticky !important;
    top: 74px;
  }

  .toc-main ul {
    counter-reset: show-list;
  }

  .toc-main ul li::before {
    content: counter(item)".";
    display: block;
    position: absolute;
    left: 12px;
    top: 0;
  } */
</style>
 

<!-- 设置导航背景 -->
<script>
  let setHeaderClass = () => {
    const nav = $('#navHeader');
    const navTop = nav.outerHeight();
    const winTop = $(window).scrollTop();
    if(winTop > navTop) {
      nav.addClass('header-bg-color');
    }
    else {
      nav.removeClass('header-bg-color');
    }
  };

  let scrollCollect = () => {
    return bamboo.throttle(function (e) {
      setHeaderClass();
    }, 200)()
  }

  let initHeaderBg = () => {
    setHeaderClass();
  }

  setHeaderClass();
  window.addEventListener('scroll', scrollCollect);

  document.addEventListener('pjax:send', function () {
    window.removeEventListener('scroll', scrollCollect)
  })
  document.addEventListener('pjax:complete', function () {
    window.addEventListener('scroll', scrollCollect);
    setHeaderClass();
  })
</script> 

<!-- 渲染issues标签里的内容 -->
<script>
  function loadIssuesJS() {
    if ($(".post-detail").find(".issues-api").length == 0) {
      return;
    } 
    loadScript('/js/issues/index.js');
  };
  $(function () {
    loadIssuesJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof IssuesAPI == "undefined") {
      loadIssuesJS();
    }
  })
</script>

<!-- 渲染远程json加载的图片标签(getPhotoOnline)里的内容 -->
<script>
  function loadPhotoOnlineJS() {
    if ($(".post-detail").find(".getJsonPhoto-api").length == 0) {
      return;
    } 
    loadScript('/js/getPhotoOnline/index.js');
  };
  $(function () {
    loadPhotoOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getPhotoJson == "undefined") {
      loadPhotoOnlineJS();
    }
  })
</script>

<!-- 渲染远程json加载的talk标签(getTalkOnline)里的内容 -->
<script>
  function loadTalkOnlineJS() {
    if ($(".post-detail").find(".getJsonTalk-api").length == 0) {
      return;
    } 
    loadScript('https://cdnjs.cloudflare.com/ajax/libs/waterfall.js/1.0.2/waterfall.min.js'); // 瀑布流插件，https://raphamorim.io/waterfall.js/
    loadScript('/js/getTalkOnline/index.js');
  };
  $(function () {
    loadTalkOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getTalkJson == "undefined") {
      loadTalkOnlineJS();
    }
  })
</script>

<!-- 渲染远程json加载的site-card标签(getSiteOnline)里的内容 -->
<script>
  function loadSiteOnlineJS() {
    if ($(".post-detail").find(".getJsonSite-api").length == 0) {
      return;
    } 
    loadScript('/js/getSiteOnline/index.js');
  };
  $(function () {
    loadSiteOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getSiteJson == "undefined") {
      loadSiteOnlineJS();
    }
  })
</script>

<!-- 输入框打字特效 -->
<!-- 输入框打字特效 -->


<!-- markdown代码一键复制功能 -->

  <link rel="stylesheet" href="https://unpkg.com/v-plugs-ayu/lib/ayu.css">
  <script src="https://unpkg.com/v-plugs-ayu/lib/ayu.umd.min.js"></script>
  <script src="/js/clipboard/clipboard.min.js"></script>
  <div id="appCopy">
  </div>
  <script data-pjax>
    var vm = new Vue({
      el: '#appCopy',
      data: {
      },
      computed: {
      },
      mounted() {
        const that = this;
        var copy = 'copy';
        /* code */
        var initCopyCode = function () {
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fas fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
            target: function (trigger) {
              return trigger.nextElementSibling;
            }
          });
        }
        initCopyCode();
        $('.btn-copy').unbind('click').bind('click', function () {
          doSomething();
        })
        $(document).unbind('keypress').bind('keypress', function (e) {
          if (e.ctrlKey && e.keyCode == 67) {
            doSomething();
          }
        })

        function doSomething() {
          that.$notify({
            title: "成功",
            content: "代码已复制，请遵守相关授权协议。",
            type: 'success'
          })
        }
      },
      methods: {
      },
      created() { }
    })
  </script>
  

<!-- 图片懒加载 -->
<script defer src="https://unpkg.com/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>


<!-- 卡片滚动动画 -->
   

<!-- 评论所需js -->

  
        <script type="text/javascript">
  var utteranceComment = {};

  function check_utterance() {
    let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
    if (isDark) {
      utteranceComment.Theme = 'github-dark';
    } else {
      utteranceComment.Theme = 'github-light';
    }

    return document.getElementById("gitment-container");
  }
  comment_el = '#gitment-container';
  load_utterance = function () {
    if ($(comment_el).length) {
      // 匿名函数，防止污染全局变量
      const HEAD = check_utterance();

      var utterances = document.createElement('script');
      utterances.type = 'text/javascript';
      utterances.async = true;
      utterances.setAttribute('issue-term', 'pathname')
      utterances.setAttribute('theme', utteranceComment.Theme)
      utterances.setAttribute('repo', '')
      utterances.crossorigin = 'anonymous';
      utterances.src = 'https://utteranc.es/client.js';
      // content 是要插入评论的地方
      document.getElementById('gitment-container').appendChild(utterances);

    }
  }

  function dark_utterance() {
    const HEAD = check_utterance();
    if (!HEAD) return;
    const message = {
      type: 'set-theme',
      theme: utteranceComment.Theme
    };
    const utteranceIframe = document.querySelector('iframe');
    utteranceIframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }

  $(document).ready(load_utterance);
  document.addEventListener('pjax:complete', function () {
    load_utterance();
  });

  $('.dark').click(function () {
    setTimeout(() => {
      dark_utterance();
    });
  })

</script>

<style>
  .utterances {
    max-width: inherit !important;
  }
</style>
      


<!-- 鼠标点击特效 -->
<!-- 爱心点击 -->





<!-- 轮播图标签 -->
<script>
  var bambooSwiperTag = {};
  function load_swiper() {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    loadCSS("https://unpkg.com/swiper@6/swiper-bundle.min.css")
    loadScript("https://unpkg.com/swiper@6/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    bambooSwiperTag.swiper = new Swiper('.post-swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      autoplay: true ? {
        delay: 3000,
        stopOnLastSlide: false,
        disableOnInteraction: false,
      } : false,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
      on:{
        init: function(){
          swiperAnimateCache(this); //隐藏动画元素 
          swiperAnimate(this); //初始化完成开始动画
        }, 
        slideChangeTransitionEnd: function(){ 
          swiperAnimate(this); //每个slide切换结束时也运行当前slide动画
          //this.slides.eq(this.activeIndex).find('.ani').removeClass('ani'); 动画只展现一次，去除ani类名
        } 
      }
    });
  }

  document.addEventListener('pjax:complete', function () {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    if (typeof bambooSwiperTag.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>
    <!-- pjax -->
    

<!-- pjax -->


  <script src="/js/pjax@0.2.8/index.js"></script>
  
    <div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
    document.addEventListener('pjax:complete', function () {
      window.HideLoading();
    })
    document.addEventListener('pjax:send', function () {
      window.ShowLoading();
    })
    document.addEventListener('pjax:error', function () {
      window.HideLoading();
    })
	</script>
</div>

  

  <script>
    var pjax = new Pjax({
      elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([no-pjax])',   // 拦截正常带链接的 a 标签
      selectors: ["#pjax-container","title"],                                   // 根据实际需要确认重载区域
      cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
      timeout: 5000
    });

    document.addEventListener('pjax:send', function (e) {

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');

    })
    
    document.addEventListener('pjax:complete', function () {
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
    });

    document.addEventListener('pjax:error', function (e) {
      window.location.href = e.triggerElement.href;
    })
    
    // 刷新不从顶部开始
    document.addEventListener("DOMContentLoaded", function () {
      history.scrollRestoration = 'auto';
    })
  </script>



  </body>
</html>