---
title: Optuna搜参优化LightGBM预测催化反应产率 
mathjax: true
date: 2025/2/25 20:46:25
img: https://img0.baidu.com/it/u=3213989145,974537053&fm=253&fmt=auto&app=120&f=PNG?w=1023&h=362
excerpt: RT
---
# 任务概述

构建一个能够准确预测碳氮成键反应产率的预测模型。  

通过对反应中所包含的反应底物、添加剂、溶剂以及产物进行合理的特征化，运用机器学习模型或者深度学习模型拟合预测反应的产率。

或者利用训练集数据对开源大语言模型进行微调以预测反应的产率。

训练集中包含19999条反应数据，测试集中包含3539条反应数据。每条训练数据包含 rxnid, Reactant1, Reactant2 , Product , Additive , Solvent , Yield字段。其中 Reactant1 , Reactant2 , Product , Additive , Solvent 字段中为对应物质的SMILES字符串，Yield字段为目标字段，是经过归一化的浮点数。

**评价指标**

实验真实结果与预测结果$R^2$决定系数来进行评测:
$$
R^2(y,\hat{y})=1-\frac{\sum_{i=1}^n(y_i-\hat{y}_i)^2}{\sum_{i=1}^n(y_i-\bar{y})^2}
$$


# baseline

1. **导入库**：首先，代码导入了需要用到的库，包括 `pandas`（用于数据处理和分析），`scikit-learn`（机器学习库），`rdkit`（化学信息工具）。
2. **读取数据**：代码通过使用 `pd.read_csv` 函数从文件中读取训练集和测试集数据。
3. **使用Morgan分子指纹建模SMILES**：

   \- 这个过程需要调用rdkit的相关模块。然后将Reactant1,Reactant2,Product,Additive,Solvent字段的向量拼接到一起，组成一个更长的向量。

1. **使用随机森林预测结果**：

   \- 这里直接调用`sklearn`的`RandomForestRegressor`模块实例化一个随机森林模型，并对`n_estimators`等重要参数进行指定。最后使用model.fit(x, y)训练模型。模型保存在本地`'./random_forest_model.pkl'`。

1. **加载模型进行预测，并将保存结果文件到本地：**

   ` pkl`文件直接使用`pickle.load()`加载，然后使用`model.predict(x)`进行预测。

## SMILES

SMILES,全称是Simplified Molecular Input Line Entry System，是一种将化学分子用ASCII字符表示的方法，是化学信息学领域非常重要的工具。

SMILES将化学分子中涉及的原子、键、电荷等信息，用对应的ASCII字符表示；环、侧链等化学结构信息，用特定的书写规范表达。以此，几乎所有的分子都可以用特定的SMILES表示，且SMILES的表示还算比较直观。

在SMILES中，原子由他们的化学符号表示，=表示双键、#表示三键、[]里面的内容表示侧基或者特殊原子（例如[Cu+2]表示带电+2电荷的Cu离子）。通过SMLIES，就可以把分子表示为序列类型的数据了。

（注：SMILES有自己的局限性：例如选择不同的起始原子，写出来的SMILES不同；它无法表示空间信息。）

由于Reactant1,Reactant2,Product,Additive,Solvent都是由SMILES表示。所以，可以使用rdkit工具直接提取SMILES的分子指纹（向量），作为特征。

## Morgan fingerprint
位向量（bit vector）形式的特征，即由0,1组成的向量。

分子指纹是一个具有固定长度的位向量（即由0，1组成），其中，每个为1的值表示这个分子具有某些特定的化学结构。

通常，分子指纹的维度都是上千的，也即记录了上千个子结构是否出现在分子中。

## RDKit

RDkit会将分子读取为RDkit中专属的rdkit.Chem.rdchem.Mol对象，并以Mol对象为基础，可以对分子进行转化为各种表达形式，例如SMILES

RDkit是化学信息学中主要的工具，是开源的。网址：http://www.rdkit.org
支持WIN\MAC\Linux，可以被python、Java、C调用。几乎所有的与化学信息学相关的内容都可以在上面找到。

## 结果

baseline的$R^2 = 0.0745336043830066$，约0.08

# My model

SMILE表达式：字符串表示分子结构的化学信息学标准。

分子指纹：它通过捕捉分子中每个原子的局部环境信息，将分子结构编码为固定长度的二进制向量或者整数向量

- 对于每个原子，根据其邻居的标识符更新自己的标识符。
- 更新规则通常基于哈希函数，将邻居的标识符组合成一个新的标识符。
- 迭代次数等于半径 r。

**具体的从SMILES表达式转成分子指纹的步骤：**

在 Morgan 指纹中，每个原子的 **初始标识符** 是基于原子的局部环境计算的。具体来说，初始标识符通常由以下原子属性决定：

- 原子类型（如 C、N、O 等）
- 原子的电荷
- 原子的度（连接的键数）
- 原子的氢原子数
- 其他可能的属性（如是否在环中）

- 哈希函数将标识符映射到一个固定范围的整数（通常是 0 到 $2^{n}-1$，其中 n是指纹的位数）。
- 例如，如果指纹长度是 1024 位，则哈希值的范围是 0 到 1023。

**指纹生成**

- 将所有原子的哈希值映射到一个固定长度的位向量中。
- 如果某个哈希值对应的位被置为 1，则表示该特征存在于分子中。

Optuna：

内含优化搜索，不用穷举式搜索，速度更快。

支持连续值，网格只支持离散值

LightGBM：

轻量级的梯度提升树

通过数据压缩使得训练更快

**为什么不用随机森林**

GBDT在大数据集上表现比RF好，LightGBM又是在XgBoost上进行优化的

**有哪些特征？**

最大叶子数量，最大深度，每个节点的最小样本数，建树随机选择的特征比例，随机选择的样本比例，正则化项系数

结果：

Best trial:
  R2: 0.32038588335457874
  Params: 
    num_leaves: 250
    learning_rate: 0.04051655617169133
    max_depth: 17
    min_data_in_leaf: 10
    feature_fraction: 0.4350306415682709
    bagging_fraction: 0.6540225841297226
    bagging_freq: 1
    lambda_l1: 0.000524499451410933
    lambda_l2: 0.01259645970374942

LGBM算法提出的核心目的是为了解决GBDT算法框架在处理海量数据时计算效率低下的问题，而从实践效果来看，LGBM也确实做到了这点——LGBM以牺牲极小的计算精度为代价，将GBDT的计算效率提升了近20倍

Optuna 相比 GridSearch 有以下优势：

1. **效率更高**
   - **GridSearch**：遍历所有参数组合，计算量大，耗时长。
   - **Optuna**：基于贝叶斯优化等算法，智能选择有潜力的参数，减少不必要的计算。
2. **支持复杂搜索空间**
   - **GridSearch**：只能处理离散参数值。
   - **Optuna**：支持连续、离散、条件参数等多种类型，适应复杂搜索空间。
3. **动态调整搜索方向**
   - **GridSearch**：固定搜索路径，无法根据结果调整。
   - **Optuna**：根据历史结果动态调整搜索方向，更快找到最优解。

就是要手动的交叉验证
