- 编译语言&解释语言

编译语言要整个文件通过编译，只需一次编译之后就能转化成机器码运行，例如cpp，Rust

解释语言逐行读取并执行代码，没有可生成可执行文件，例如Python，JS，PHP

还有混合型语言，采用字节码编译+虚拟机解释，例如Java，C#，Lua

- C++是静态类型语言，变量类型不可变。

- using关键词解决很长的类型表达，auto自动选择类型，仍然是静态类型

初始化

1. 直接初始化

不会检查类型，会强转（例如double -> int）

```c++
int num1 = 12.0;
int num2(12.0);
```

2. 统一初始化（C++11）

使用花括号，会检查类型，报错

```c++
int num{12.0}; // 报错
```

安全，适用范围广（vector，map，自定义类）

3. 结构化绑定（C++17）

一种在编译时从固定大小的数据结构中初始化某些变量的方法，能访问函数返回的多个值

注：`std::tuple` 是 C++11 引入的一个模板类，用于将多个不同类型的值组合成一个单一对象。它类似于结构体，但不需要预先定义类型名称

```c++
std::tuple<std::string, std::string, std::string> getClassInfo() {
    std::string className = "CS106L";
	std::string buildingName = "260-113";
	std::string language = "C++";
    return {className, buildingName, language};
}
int main(){
    auto [className, buildingName, language] = getClassInfo();
    // 或者
    auto classInfo = getClassInfo();
	std::string className = std::get<0>(classInfo);
    std::string buildingName = std::get<1>(classInfo);
    std::string language = std::get<2>(classInfo);
}
```

- &引用，可以看成是原来变量的别名，对应同一内存地址

```c++
void shift(std::vector<std::pair<int, int>> &nums) {
    for (auto &[num1, num2] : nums) {
        num1++;
        num2++;
    }
}
//或者
void shift(std::vector<std::pair<int, int>> &nums) {
     for (size_t i = 0; i < nums.size(); i++) {
         nums[i].first++;
         nums[i].second++;
     }
}
```

- 左值&右值

左值：由明确内存位置的表达式，可以取地址

右值：临时变量，没有持久的内存地址

- const

不能给const变量设置一个不是const的引用对象

- 编译

```sh
g++ -std=c++23 file.cpp -o exename
```